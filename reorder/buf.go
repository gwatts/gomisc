// Package reorder provides a buffer that re-orders written to it.
//
// Data may be written to the buffer out of order, and it will be buffered
// until a contiguous slice of data is available to be flushed to an
// underlying Writer.
package reorder

import (
	"errors"
)

var (
	errNilMarker = errors.New("no value") // end user should never see this value passed to flush
)

// ErrBufferFull is returned if the Buffer is at capacity.
var ErrBufferFull = errors.New("buffer full")

// Writer is an interface which wraps a Write method called by a
// Buffer when sequential and contiguous data is ready to
// be processed.
//
// n holds the sequence number of the first item in the supplied buffer
// with each sequential item in the buffer having a value of n+i.
//
// Any error returned from Write will be propagated to the caller of Add
// and another attempt to flush the data will be made on the next call
// to Add.
type Writer interface {
	Write(n int, buf []interface{}) error
}

// WriterFunc adapts the supplied function so that it complies with the Writer interface.
type WriterFunc func(n int, buf []interface{}) error

// Write calls wf(n, buf)
func (wf WriterFunc) Write(n int, buf []interface{}) error {
	return wf(n, buf)
}

// Buffer accepts data written out of order and flushes it to a
// writer in sequential, contiguous slices.
//
// Each item in the buffer must have a sequence number associated with it
// and the first item in the sequence must be zero (though, of course, it
// does not have to be the first item supplied to Add).
//
// Sequence numbers must ultimately be contiguous for data to be flushed
// to the Writer.
type Buffer struct {
	maxSize int
	n       int
	buf     []interface{}
	writer  Writer
}

// NewBuffer creates a new Buffer ready for write
func NewBuffer(maxSize int, w Writer) *Buffer {
	return &Buffer{
		n:       -1,
		maxSize: maxSize,
		writer:  w,
	}
}

// Add adds a new item to the buffer.
//
// n indicates the items sequence number:  It must be greater than the last
// flushed contiguous slice.  Sequence numbers must become contiguous at some
// point for a flush to occur, and sequence numbers start at zero.
//
// If n is equal to the highest last flushed sequence number plus one, then
// at least one item will flush immediately during this call (ie. from the
// same goroutine; no goroutines are generated by this buffer).
//
// item may consist of any value, including nil.
//
// An error is returned if adding an entry to the buffer would exceed the
// maximum buffer size, or if an error is returned from flush.
//
// Add does not implement any locking, so is not safe to call from multiple
// goroutines; wrap the call with a mutex if such behaviour is needed.
func (b *Buffer) Add(n int, item interface{}) error {
	if n <= b.n {
		panic("n must be greater than previous values")
	}

	// fast path
	if n == b.n+1 && len(b.buf) == 0 {
		err := b.writer.Write(n, []interface{}{item})
		if err == nil {
			b.n = n
			return nil
		}
		// buffer
		b.buf = append(b.buf, item)
		return err
	}

	// extend buf, if necessary
	offset := n - b.n
	if b.maxSize > 0 && offset > b.maxSize {
		return ErrBufferFull
	}
	b.buf = grow(offset, b.buf)

	b.buf[offset-1] = item

	// check if buf is now contiguous
	var end int = -1
	var bi interface{}
	for end, bi = range b.buf {
		if bi == errNilMarker {
			end--
			break
		}
	}

	if end > -1 {
		// contiguous; flush
		if err := b.writer.Write(b.n+1, b.buf[:end+1]); err != nil {
			return err
		}
		b.buf = b.buf[end+1:]
		b.n += end + 1
	}
	return nil
}

func grow(size int, buf []interface{}) []interface{} {
	if len(buf) >= size {
		return buf
	}

	for cap(buf) < size {
		buf = append(buf, errNilMarker)
	}

	i := len(buf)
	buf = buf[:size]
	for ; i < size; i++ {
		buf[i] = errNilMarker
	}

	return buf
}
